// ========== TEXTCARD - FIX D√âFINITIF TITRE HEADER ==========

class TextCard extends BaseCard {
    constructor(cardData, workspaceManager) {
        // Donn√©es par d√©faut pour les cartes texte
        const textDefaults = {
            type: 'text',
            mainTitle: cardData.mainTitle || 'TITRE', // Sera modifi√© par GPT
            client: cardData.client || 'Client',
            dossier: cardData.dossier || 'Nouveau dossier',
            departement: cardData.departement || 'D√©partement',
            repertoires: cardData.repertoires || [],
            theme: cardData.theme || cardData.client || 'Personnalis√©',
            description: cardData.description || cardData.dossier || 'Description de la carte',
            stats: cardData.stats || { documents: 0, lastUpdate: 'maintenant' },
            documentContent: cardData.documentContent || null
        };

        super({ ...textDefaults, ...cardData }, workspaceManager);
        this.isDocumentMode = false;
        this.loadDocumentContent();
    }

    getHTML() {
        const actions = [
            { 
                class: 'chat-toggle-btn', 
                icon: 'fas fa-edit', 
                title: 'Mode Collaboration' 
            },
            { 
                class: 'clear-content-btn', 
                icon: 'fas fa-eraser', 
                title: 'Vider le contenu' 
            }
        ];

        return `
            ${CardSystem.createCardHeader(this.data, actions)}
            
            <div class="card-content-view" id="content-${this.data.id}">
                <div class="card-category-section">
                    <div class="category-tag" id="category-${this.data.id}">
                        ${this.data.category || 'Document de travail'}
                    </div>
                </div>
                
                <div class="card-summary-section">
                    <div class="card-summary-text" id="summary-${this.data.id}">
                        ${this.generateSummary()}
                    </div>
                </div>
                
                <div class="card-filing-section">
                    <div class="filing-folder">
                        <svg class="folder-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24">
                            <path d="M10 4l2 2h8a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h6z"
                                  fill="rgba(253, 224, 71, 0.6)" />
                        </svg>
                        <select class="filing-select" id="filing-select-${this.data.id}">
                            ${this.getFilingOptionsHTML()}
                        </select>
                    </div>
                </div>
            </div>
            
            <div class="card-document-view" id="document-${this.data.id}" style="display: none;">
                <div class="document-content" contenteditable="true" id="doc-content-${this.data.id}">
                    <div class="document-body" id="doc-body-${this.data.id}">
                        <p class="document-placeholder">Commencez √† taper ou utilisez l'IA pour g√©n√©rer du contenu...</p>
                    </div>
                </div>
                
                <div class="collaboration-indicator" id="collab-indicator-${this.data.id}" style="display: none;">
                    <svg class="collab-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24">
                        <circle cx="9" cy="8" r="2.5" fill="rgba(59,130,246,0.4)" stroke="rgba(255,255,255,0.8)" stroke-width="1"/>
                        <path d="M4.5 19c0-2.5 2-4 4.5-4s4.5 1.5 4.5 4" stroke="rgba(255,255,255,0.8)" stroke-width="1" fill="none"/>
                        <rect x="15" y="7" width="4" height="4" rx="1" fill="rgba(16,185,129,0.4)" stroke="rgba(255,255,255,0.8)" stroke-width="1"/>
                        <circle cx="16" cy="8.5" r="0.5" fill="rgba(255,255,255,0.9)"/>
                        <circle cx="18" cy="8.5" r="0.5" fill="rgba(255,255,255,0.9)"/>
                        <path d="M15 11v2c0 1 2 2 2s2-1 2-2v-2" stroke="rgba(255,255,255,0.8)" stroke-width="1" fill="none"/>
                    </svg>
                    <span class="collab-text">Collaboration active</span>
                </div>
            </div>
        `;
    }

    getRepertoiresHTML() {
        if (!this.data.repertoires || !Array.isArray(this.data.repertoires)) return '';
        
        return this.data.repertoires.map(rep => `
            <div class="repertoire-item">
                <i class="fas fa-folder" style="color: #f1c40f;"></i>
                <span>${rep}</span>
            </div>
        `).join('');
    }

    setupSpecificEvents() {
        // Events sp√©cifiques aux cartes texte
        const chatToggleBtn = this.element.querySelector('.chat-toggle-btn');
        const clearContentBtn = this.element.querySelector('.clear-content-btn');
        
        chatToggleBtn?.addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggleDocumentMode();
        });
        
        clearContentBtn?.addEventListener('click', (e) => {
            e.stopPropagation();
            this.clearDocumentContent();
        });

        // Event de saisie dans le document
        const docContent = this.element.querySelector('.document-content');
        if (docContent) {
            docContent.addEventListener('input', () => {
                this.saveDocumentContent();
            });
        }

        // ‚ö° CORRECTION : Event pour le titre √©ditable dans le header
        const mainTitle = this.element.querySelector('.card-title');
        if (mainTitle) {
            mainTitle.addEventListener('input', () => {
                const newTitle = mainTitle.textContent.trim() || 'TITRE';
                // ‚ö° Mettre √† jour les DEUX champs
                this.data.title = newTitle;
                this.data.mainTitle = newTitle;
                this.saveData();
                console.log(`üìù Titre modifi√© manuellement: ${newTitle}`);
            });
            
            mainTitle.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    mainTitle.blur();
                }
            });
            
            // Emp√™cher le drag quand on √©dite le titre
            mainTitle.addEventListener('mousedown', (e) => {
                e.stopPropagation();
            });
            
            mainTitle.addEventListener('click', (e) => {
                e.stopPropagation();
            });
        }

        // Event pour changement de r√©pertoire
        const filingSelect = this.element.querySelector(`#filing-select-${this.data.id}`);
        if (filingSelect) {
            filingSelect.addEventListener('change', (e) => {
                const newFolder = e.target.value;
                this.data.filingFolder = newFolder;
                this.saveData();
                console.log(`üìÅ R√©pertoire chang√© manuellement: ${newFolder}`);
            });
            
            // Emp√™cher le drag sur la dropdown
            filingSelect.addEventListener('mousedown', (e) => e.stopPropagation());
            filingSelect.addEventListener('click', (e) => e.stopPropagation());
        }
    }

    toggleDocumentMode() {
        const documentView = this.element.querySelector('.card-document-view');
        const contentView = this.element.querySelector('.card-content-view');
        const toggleBtn = this.element.querySelector('.chat-toggle-btn');
        
        this.isDocumentMode = documentView.style.display !== 'none';
        
        if (this.isDocumentMode) {
            // Retour au mode normal
            documentView.style.display = 'none';
            contentView.style.display = 'block';
            this.element.classList.remove('document-mode');
            toggleBtn.classList.remove('active');
            toggleBtn.innerHTML = '<i class="fas fa-edit"></i>';
            toggleBtn.title = 'Mode Collaboration';
            // Masquer l'indicateur de collaboration
            const collabIndicatorHide = this.element.querySelector(`#collab-indicator-${this.data.id}`);
            if (collabIndicatorHide) {
                collabIndicatorHide.style.display = 'none';
            }
            
            if (this.workspaceManager.activeCardChat === this.data.id) {
                this.workspaceManager.disconnectFromMainChat();
            }
        } else {
            // Passage au mode document
            documentView.style.display = 'block';
            contentView.style.display = 'none';
            this.element.classList.add('document-mode');
            toggleBtn.classList.add('active');
            toggleBtn.innerHTML = '<i class="fas fa-file-alt"></i>';
            toggleBtn.title = 'Retour vue normale';
            // Afficher l'indicateur de collaboration
            const collabIndicatorShow = this.element.querySelector(`#collab-indicator-${this.data.id}`);
            if (collabIndicatorShow) {
                collabIndicatorShow.style.display = 'flex';
            }
            
            this.workspaceManager.connectToMainChat(this.data.id, this.element);
            
            const docContent = this.element.querySelector('.document-content');
            if (docContent) {
                docContent.focus();
            }
        }
        
        this.isDocumentMode = !this.isDocumentMode;
    }

    saveDocumentContent() {
        const docBody = this.element.querySelector(`#doc-body-${this.data.id}`);
        if (!docBody) return;
        
        const content = docBody.innerHTML;
        this.data.documentContent = content;
        this.saveData();
        localStorage.setItem(`workspace-doc-${this.data.id}`, content);
    }

    loadDocumentContent() {
        // Charger le contenu depuis localStorage
        const content = localStorage.getItem(`workspace-doc-${this.data.id}`);
        if (content) {
            this.data.documentContent = content;
        }
    }

    afterRender() {
        // Restaurer le contenu du document apr√®s le rendu
        if (this.data.documentContent) {
            const docBody = this.element.querySelector(`#doc-body-${this.data.id}`);
            if (docBody) {
                docBody.innerHTML = this.data.documentContent;
            }
        }
    }

    clearDocumentContent() {
        if (confirm('Vider tout le contenu de ce document ?')) {
            const docBody = this.element.querySelector(`#doc-body-${this.data.id}`);
            if (docBody) {
                docBody.innerHTML = '<p class="document-placeholder">Commencez √† taper ou utilisez l\'IA pour g√©n√©rer du contenu...</p>';
            }
            
            this.data.documentContent = null;
            this.saveData();
            localStorage.removeItem(`workspace-doc-${this.data.id}`);
            
            console.log(`Document vid√© pour la carte ${this.data.id}`);
        }
    }

    getDocumentContent() {
        const docBody = this.element.querySelector(`#doc-body-${this.data.id}`);
        if (!docBody) return '';
        
        return docBody.textContent || docBody.innerText || '';
    }

    // ========== M√âTHODES GPT - VERSION SIMPLIFI√âE ET DEBUGG√âE ==========

    addDocumentSection(sectionTitle, token) {
        console.log(`üîß [${this.data.id}] addDocumentSection appel√©e avec token: ${token}`);
        
        const docBody = this.element.querySelector(`#doc-body-${this.data.id}`);
        if (!docBody) {
            console.error(`‚ùå [${this.data.id}] docBody non trouv√© !`);
            return;
        }
        
        // Supprimer le placeholder s'il existe
        const placeholder = docBody.querySelector('.document-placeholder');
        if (placeholder) {
            placeholder.remove();
            console.log(`üîß [${this.data.id}] Placeholder supprim√©`);
        }
        
        // Cr√©er juste une div de contenu, SANS titre de section
        const sectionHTML = `
            <div class="document-section" id="section-${token}">
                <div class="section-content" id="content-${token}">
                    <span class="typing-cursor">‚ñä</span>
                </div>
            </div>
        `;
        
        docBody.insertAdjacentHTML('beforeend', sectionHTML);
        docBody.scrollTop = docBody.scrollHeight;
        
        console.log(`‚úÖ [${this.data.id}] Section cr√©√©e pour token: ${token}`);
    }

    updateDocumentSection(token, content) {
        console.log(`üîß [${this.data.id}] updateDocumentSection - token: ${token}, content: ${content.substring(0, 50)}...`);
        
        const sectionContent = this.element.querySelector(`#content-${token}`);
        if (!sectionContent) {
            console.error(`‚ùå [${this.data.id}] Section content non trouv√©e pour token: ${token}`);
            return;
        }
        
        const formattedContent = this.formatDocumentContent(content);
        sectionContent.innerHTML = formattedContent + '<span class="typing-cursor">‚ñä</span>';
        
        const docBody = this.element.querySelector(`#doc-body-${this.data.id}`);
        if (docBody) {
            docBody.scrollTop = docBody.scrollHeight;
        }
    }

    finalizeDocumentSection(token, content) {
        console.log(`üîß [${this.data.id}] finalizeDocumentSection - token: ${token}`);
        console.log(`üîß [${this.data.id}] Contenu final (100 premiers caract√®res):`, content.substring(0, 100));
        
        const sectionContent = this.element.querySelector(`#content-${token}`);
        if (!sectionContent) {
            console.error(`‚ùå [${this.data.id}] Section content non trouv√©e pour finalisation !`);
            return;
        }
        
        // Ex√©cuter les commandes JavaScript avant tout
        this.executeJavaScriptCommands(content);
        
        // Nettoyer le contenu en supprimant les blocs JavaScript
        const cleanContent = this.removeJavaScriptBlocks(content);
        
        // Formater le contenu pour l'affichage
        const formattedContent = this.formatDocumentContent(cleanContent);
        sectionContent.innerHTML = formattedContent;
        
        // Enregistrer le contenu
        this.saveDocumentContent();
        
        // Mettre √† jour le r√©sum√©
        this.updateSummary();
    }
    
    /**
     * Ex√©cute les commandes JavaScript trouv√©es dans le contenu
     * @param {string} content - Le contenu √† analyser
     */
    executeJavaScriptCommands(content) {
        console.log(`üîß [${this.data.id}] Recherche de commandes JavaScript...`);
        
        // D√©tecter card.setTitle("...")
        const setTitleRegex = /card\.setTitle\s*\(\s*["']([^"']+)["']\s*\)/g;
        let titleMatch;
        while ((titleMatch = setTitleRegex.exec(content)) !== null) {
            const titleValue = titleMatch[1];
            try {
                this.setTitle(titleValue);
                console.log(`‚úÖ [${this.data.id}] setTitle ex√©cut√©:`, titleValue);
            } catch (error) {
                console.error(`‚ùå [${this.data.id}] Erreur setTitle:`, error);
            }
        }
        
        // D√©tecter card.setCategory("...")
        const setCategoryRegex = /card\.setCategory\s*\(\s*["']([^"']+)["']\s*\)/g;
        let categoryMatch;
        while ((categoryMatch = setCategoryRegex.exec(content)) !== null) {
            const categoryValue = categoryMatch[1];
            try {
                this.setCategory(categoryValue);
                console.log(`‚úÖ [${this.data.id}] setCategory ex√©cut√©:`, categoryValue);
            } catch (error) {
                console.error(`‚ùå [${this.data.id}] Erreur setCategory:`, error);
            }
        }
        
        // D√©tecter card.setFolder("...")
        const setFolderRegex = /card\.setFolder\s*\(\s*["']([^"']+)["']\s*\)/g;
        let folderMatch;
        while ((folderMatch = setFolderRegex.exec(content)) !== null) {
            const folderValue = folderMatch[1];
            try {
                this.setFolder(folderValue);
                console.log(`‚úÖ [${this.data.id}] setFolder ex√©cut√©:`, folderValue);
            } catch (error) {
                console.error(`‚ùå [${this.data.id}] Erreur setFolder:`, error);
            }
        }
        
        // D√©tecter les blocs ```javascript ... ` ``
        const jsBlockRegex = /```javascript\s*\n([\s\S]*?)\n` ``/g;
        let match;
        while ((match = jsBlockRegex.exec(content)) !== null) {
            const jsCode = match[1].trim();
            try {
                const contextualCode = jsCode.replace(/\bcard\./g, 'this.');
                eval(contextualCode);
                console.log(`‚úÖ [${this.data.id}] Code JS ex√©cut√©:`, jsCode);
            } catch (error) {
                console.error(`‚ùå [${this.data.id}] Erreur JS:`, error);
            }
        }
    }
    
    /**
     * Nettoie le contenu en supprimant les blocs JavaScript et les commandes isol√©es
     * @param {string} content - Le contenu √† nettoyer
     * @returns {string} Le contenu nettoy√©
     */
    removeJavaScriptBlocks(content) {
        console.log(`üîß [${this.data.id}] Contenu AVANT nettoyage:` , content.substring(0, 200));
        
        // Supprimer les blocs ```javascript ... ` ``
        let cleanContent = content.replace(/```javascript\s*\n[\s\S]*?\n` ``/gs, '');
        cleanContent = cleanContent.replace(/```javascript[\s\S]*?` ``/gs, '');
        
        // Supprimer les lignes card.setTitle isol√©es
        cleanContent = cleanContent.replace(/^\s*card\.setTitle\s*\([^)]+\)\s*;?\s*$/gm, '');
        
        // Supprimer les lignes card.setCategory isol√©es
        cleanContent = cleanContent.replace(/^\s*card\.setCategory\s*\([^)]+\)\s*;?\s*$/gm, '');
        
        // Supprimer les lignes card.setFolder isol√©es
        cleanContent = cleanContent.replace(/^\s*card\.setFolder\s*\([^)]+\)\s*;?\s*$/gm, '');
        
        // Supprimer les balises <script>
        cleanContent = cleanContent.replace(/<script[^>]*>[\s\S]*?<\/script>/gi, '');
        
        // Nettoyer les lignes vides
        cleanContent = cleanContent.replace(/^\s*$/gm, '');
        cleanContent = cleanContent.replace(/\n{3,}/g, '\n\n');
        
        console.log(`‚úÖ [${this.data.id}] Contenu APR√àS nettoyage:` , cleanContent.substring(0, 200));
        
        return cleanContent.trim();
    }

    formatDocumentContent(content) {
        if (!content) return '';
        
        // ‚ö° IMPORTANT : Garder le contenu brut pour l'extraction de titre
        // mais formater pour l'affichage
        return content
            .replace(/\n\n+/g, '</p><p>')
            .replace(/\n/g, '<br>')
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
            .replace(/\*(.*?)\*/g, '<em>$1</em>')
            .replace(/#{1,3}\s*(.+?)(<br>|$)/g, '<strong>$1</strong>$2'); // Transformer ## en gras
    }


    
    cleanup() {
        // Nettoyage sp√©cifique aux cartes texte
        if (this.workspaceManager.activeCardChat === this.data.id) {
            this.workspaceManager.disconnectFromMainChat();
        }
    }
    
    /**
     * D√©finit le titre de la carte et met √† jour l'affichage
     * @param {string} newTitle - Le nouveau titre √† d√©finir
     */
    setTitle(newTitle) {
        if (newTitle && newTitle.trim().length > 0) {
            this.data.title = newTitle.trim();
            this.data.mainTitle = newTitle.trim();
            
            const titleElement = this.element.querySelector('.card-title');
            if (titleElement) {
                titleElement.textContent = newTitle.trim();
            }
            
            this.saveData();
            console.log(`‚úÖ [${this.data.id}] Titre d√©fini par GPT: "${newTitle.trim()}"`);
        }
    }

    // D√©finit la cat√©gorie de la carte et met √† jour l'affichage
    setCategory(category) {
        if (category && category.trim().length > 0) {
            this.data.category = category.trim();
            
            const categoryElement = this.element.querySelector(`#category-${this.data.id}`);
            if (categoryElement) {
                categoryElement.textContent = category.trim();
            }
            
            this.saveData();
            console.log(`‚úÖ [${this.data.id}] Cat√©gorie d√©finie par GPT: "${category.trim()}"`);
        }
    }

    // D√©finit le r√©pertoire de classement (folder) et met √† jour l'affichage
    setFolder(folder) {
        if (folder && folder.trim().length > 0) {
            this.data.filingFolder = folder.trim();
            
            // Mettre √† jour la dropdown
            const filingSelect = this.element.querySelector(`#filing-select-${this.data.id}`);
            if (filingSelect) {
                filingSelect.value = folder.trim();
            }
            
            this.saveData();
            console.log(`‚úÖ [${this.data.id}] R√©pertoire d√©fini par GPT: "${folder.trim()}"`);
        }
    }

    // G√©n√®re un r√©sum√© textuel du contenu du document
    generateSummary() {
        const content = this.getDocumentContent();
        
        if (!content || content.trim().length === 0) {
            return "Document vide - Cliquez pour ajouter du contenu";
        }
        
        // Extraire les premiers mots significatifs (ignorer les titres)
        const cleanContent = content
            .replace(/^#{1,6}\s+/gm, '') // Supprimer les # des titres
            .replace(/\*\*(.*?)\*\*/g, '$1') // Supprimer le gras
            .replace(/\*(.*?)\*/g, '$1') // Supprimer l'italique
            .trim();
        
        // Prendre les 100 premiers caract√®res
        let summary = cleanContent.substring(0, 100);
        
        // Couper au dernier mot complet
        if (summary.length === 100) {
            const lastSpace = summary.lastIndexOf(' ');
            if (lastSpace > 50) { // Minimum 50 caract√®res
                summary = summary.substring(0, lastSpace);
            }
            summary += '...';
        }
        
        return summary || "Contenu en cours de r√©daction...";
    }

    // Met √† jour l'√©l√©ment d'aper√ßu de r√©sum√© dans l'UI
    updateSummary() {
        const summaryElement = this.element.querySelector(`#summary-${this.data.id}`);
        if (summaryElement) {
            summaryElement.textContent = this.generateSummary();
            console.log(`‚úÖ [${this.data.id}] R√©sum√© mis √† jour`);
        }
    }

    // Retourne les options HTML pour la liste de s√©lection du r√©pertoire de classement
    getFilingOptionsHTML() {
        const allFolders = TextCard.getAllFolders();
        const currentFolder = this.data.filingFolder || 'Documents de travail';
        
        return allFolders.map(folder => 
            `<option value="${folder}" ${folder === currentFolder ? 'selected' : ''}>${folder}</option>` 
        ).join('');
    }

    // M√©thodes statiques utilitaires pour les r√©pertoires
    static getAllFolders() {
        return [
            "Contrats", "Correspondance", "Documents de travail", "Factures de fournisseurs",
            "Office", "Portefeuilles", "Recherches", "Surveillance", "Contre-interrogatoire",
            "Preuve", "Rapports de recherches", "Registraire", "Proc√©dures", 
            "Rapports de surveillance", "Contrats et formulaires", "Transferts de dossiers",
            "Arbitrage", "Cour d'appel du Qu√©bec", "Cour d'appel f√©d√©rale", 
            "Cour f√©d√©rale (Demandes)", "Cours provinciales", "Proc√®s", "R√®glement",
            "Autorit√© R√©glementaire", "Concours", "Conditions g√©n√©rales de vente",
            "Incident", "Mat√©riel publicitaire", "Opinions", "Mises en demeure",
            "Op√©rationnalisation", "Documents de cl√¥ture", "V√©rification diligente",
            "Livre Corporatif", "Gouvernance", "R√©unions", "Incidents", "Opinion / Avis"
        ];
    }

    static getRandomFolder() {
        const folders = TextCard.getAllFolders();
        const randomIndex = Math.floor(Math.random() * folders.length);
        return folders[randomIndex];
    }

    // M√©thodes statiques pour la cr√©ation de cartes texte
    static createDefaultTextCard(cardData = {}) {
        const position = cardData.position || { x: 200, y: 200 };
        return {
            id: CardSystem.generateCardId('text'),
            type: 'text',
            title: 'TITRE',              // ‚ö° Titre par d√©faut coh√©rent
            mainTitle: 'TITRE',          // ‚ö° MainTitle par d√©faut coh√©rent
            theme: 'Personnalis√©',
            description: 'Nouvelle carte de collaboration',
            position,
            stats: { documents: 0, lastUpdate: 'maintenant' },
            pinned: false,
            documentContent: null,
            // Champs de classement et cat√©gorisation
            category: 'Document de travail',
            filingDepartment: 'AVOCAT',
            filingCategory: 'G√âN√âRAL (AVOCAT)',
            filingFolder: TextCard.getRandomFolder(),
            // ‚ö° Ajout des champs manquants
            client: 'Client',
            dossier: 'Nouveau dossier', 
            departement: 'D√©partement',
            repertoires: []
        };
    }
}

// Export
if (typeof module !== 'undefined' && module.exports) {
    module.exports = TextCard;
} else {
    window.TextCard = TextCard;
}
